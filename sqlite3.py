# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uMBZH5nDnVStJHKScIdBcGKAgqzkT4SG
"""

import sqlite3
from sqlalchemy.sql.schema import ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, String, DateTime, Integer, create_engine, Date, Table, MetaData
from sqlalchemy.orm import relationship
from datetime import datetime, timedelta,date
Base = declarative_base()

from sqlalchemy.sql.schema import ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, String, DateTime, Integer, create_engine
from sqlalchemy.orm import relationship,sessionmaker, Session
from datetime import datetime,date

con = sqlite3.connect('new1.db')
c = con.cursor()

c.execute("""
Create table if not exists Users
(
  user_id INTEGER PRIMARY KEY, 
  username TEXT not null unique)""") 

c.execute("""
Create table if not exists Accounts
(

  account_id INTEGER PRIMARY KEY,
  user_id TEXT REFERENCES Users(user_id),
  balance INTEGER not null)""")

c.execute("""
Create table if not exists Transactions
(

  transaction_id INTEGER PRIMARY KEY,
  account_id TEXT REFERENCES Accounts(account_id),
  ammount INTEGER not null,
  created_at DATE not null,
  status TEXT not null)""")

class User(Base):
  __tablename__ = "Users"
  user_id = Column(Integer(), primary_key = True)
  username = Column(String(20), nullable = False, unique = True)
  
  def __rep__(self):
    return f"<User username = {self.username}"
  def get_tablename_(self):
    return self.__tablename__
  def get_user_id(self):
    return self.user_id
  def get_username(self):
    return self.username
  def add_user(self):
    qry = """ INSERT INTO Users(user_id, username)VALUES
    ('{id}', '{username}')
   """
    new_qry = qry.format(id = self.user_id, username = self.username)
    c.execute(new_qry)
  


class Account(Base):
  __tablename__ = "Accounts"
  account_id = Column(Integer(), primary_key = True)
  user_id = Column(Integer, ForeignKey('User.user_id'))
  balance = 0
  
  def get_tablename_(self):
    return self.__tablename__
  def get_account_id(self):
    return self.account_id
  def get_userid(self):
    return self.user_id
  def get_balance(self):
    return self.balance
  def add_account(self):
    qry = """ INSERT INTO Accounts(account_id, user_id, balance)VALUES
    ('{acc_id}','{usr_id}','{bal}')
    """
    new_qry = qry.format(acc_id = self.account_id, usr_id = self.user_id, bal = self.balance )
    c.execute(new_qry)

class Transaction(Base):
  
  __tablename__ = "Transactions"
  transaction_id = Column(Integer(), primary_key = True)
  account_id = Column(Integer, ForeignKey('Accounts.account_id'), nullable = False)
  ammount = Column(Integer(), nullable = False)
  created_at = Column(DateTime(),nullable = False, default = datetime.utcnow)
  status= "PENDING"
  def add_transaction(self):
    if(data.status == 'DECLINED' or (data.status == 'ACCEPTED') or (data.status == 'PENDING') ):
        qry = """ INSERT INTO Transactions(transaction_id, account_id, ammount, created_at, status) VALUES
        ('{trans_id}','{acc_id}','{amt}', '{created}','{stat}')
        """
        new_qry = qry.format(trans_id = self.transaction_id ,acc_id = self.account_id, 
            amt = self.ammount, created = self.created_at, stat = self.status)
        print(new_qry)
        c.execute(new_qry)
    else:
        print("Transaction has an invalid status")

  def update_status(self, new_status):
    if (((new_status == 'DECLINED') or (new_status == 'ACCEPTED')) and (self.status == 'PENDING')):
      qry1 ="""UPDATE Transactions 
      SET status = '{sts}'
      WHERE transaction_id = '{id}' """
      new_qry1 = qry1.format(sts = new_status, id = self.transaction_id)
      c.execute(qry1)
      con.commit()

      if ((new_status == 'DECLINED') and (self.status != 'DECLINED')):
        self.status = 'DECLINED'
      if (new_status == 'ACCEPTED'and (self.status != 'ACCEPTED')):
        self.status = 'ACCEPTED'

        qry2 = """SELECT Accounts.balance from Transactions
            JOIN Accounts on Accounts.account_id = Transactions.account_id 
            WHERE Transactions.transaction_id = '{id}' """

        new_qry2 = qry2.format(id = self.transaction_id)
        c.execute(qry2)
        balance = c.fetchone()[0]
        new_balance = balance + self.ammount
        qry3 ="""UPDATE Accounts
          SET balance = '{new_bal}'
          WHERE account_id = '{id}' """
        new_qry3 = qry3.format(new_bal = new_balance, id = self.account.id)
        c.execute(new_qry3)
        con.commit()

def get_user_balance(username):
  qry =   """SELECT balance from Users 
  JOIN Accounts on Users.user_id = Accounts.user_id 
  JOIN Transactions on Accounts.account_id = Transactions.account_id 
  WHERE Users.username == '{usernm}' """
  new_qry = qry.format(usernm = username)
  c.execute(new_qry)
  bal = c.fetchone()
  return bal[0]

def helper(day,month,year):
  while(True):
    try:
      new = date(year, month, day)
      break
    except:
      day = day -1
  return new

def within_month():
  today = date.today()

  if today.month == 1:
    year = today.year - 1
    month = 12
  else:
    year = today.year
    month = today.month - 1
    
  earliest = helper(today.day,month,year)
  qry =   """SELECT * from Transactions WHERE created_at between
   {early} and {tdy}"""
   
  new_qry = qry.format(early = earliest, tdy = today)
  c.execute(new_qry)
  result = c.fetchall()
  for s in result:
   print(f"transaction_id{s[0]} account_id{s[1]} ammount{s[2]} created_at {s[3]} status{s[4]}")
